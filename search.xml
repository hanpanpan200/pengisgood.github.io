<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac上的JDK多版本管理]]></title>
    <url>%2F2019%2F09%2Fmanage-multiple-java-versions-on-mac%2F</url>
    <content type="text"><![CDATA[我的Mac上已经有一个JDK8的版本了，这不JDK13刚发布（2019-09-17），想快速的尝一尝鲜，就得安装多个版本的JDK了。这个对Node、Ruby、Python的使用者来说，已经不是个什么新鲜话题了，但是对于Java的使用者来说，似乎没有那么多的人受到过多版本的折磨（我是通过GitHub上nvm、rbenv、pyenv、jenv的Star数量臆测出这个结论的 :P）。 nvm rbenv pyenv jenv 安装JDK 13通过Homebrew 安装JDK 13，可以先通过brew cask info java查看目前Java的版本： 12345678java: 13,33:5b8a42f3905b406298b72d750b6919f6https://openjdk.java.net/Not installedFrom: https://github.com/Homebrew/homebrew-cask/blob/master/Casks/java.rb==&gt; NameOpenJDK Java Development Kit==&gt; Artifactsjdk-13.jdk -&gt; /Library/Java/JavaVirtualMachines/openjdk-13.jdk (Generic Artifact) 这里显示的是JDK13，正好是我想要安装的JDK版本，如果不是你想要的版本可以自己搜索相应的 Homebrew Tap。接下来直接安装: 123456$ brew cask install java$ java -versionopenjdk version "13" 2019-09-17OpenJDK Runtime Environment (build 13+33)OpenJDK 64-Bit Server VM (build 13+33, mixed mode, sharing) 这就说明JDK13已经安装好了。 但是另一个问题来了，我电脑上原来安装的JDK8去哪呢？我如何在不同的版本中随意切换呢？比如像Node的nvm，Ruby的rvm，Python的pyenv等。答案是我们可以通过jenv来实现相同的效果。 安装 jEnv 安装 jEnv12$ brew install jenv$ exec $SHELL -l 安装完成之后，然后检查是否安装成功。 1234567$ jenv doctor[OK] No JAVA_HOME set[ERROR] Java binary in path is not in the jenv shims.[ERROR] Please check your path, or try using /path/to/java/home is not a valid path to java installation. PATH : /usr/local/Cellar/jenv/0.5.2/libexec/libexec:/Users/xxx/.cargo/bin:/Users/xxx/.pyenv/shims:/Users/username/.pyenv:/Users/xxx/.nvm/versions/node/v8.11.4/bin:/Users/xxx/bin:/usr/local/bin:/Users/xxx/.cargo/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/go/bin:/Users/xxx/Documents/Projects/golang/bin[ERROR] Jenv is not loaded in your zsh[ERROR] To fix : cat eval "$(jenv init -)" &gt;&gt; /Users/xxx/.zshrc 在这里如果按照提示执行cat eval &quot;$(jenv init -)&quot; &gt;&gt; /Users/xxx/.zshrc：可能会得到如下错误： 12345678910111213141516171819202122cat eval "$(jenv init -)" &gt;&gt; /Users/xxx/.zshrccat: eval: No such file or directorycat: export PATH="/Users/xxx/.jenv/shims:$&#123;PATH&#125;"export JENV_SHELL=zshexport JENV_LOADED=1unset JAVA_HOMEsource '/usr/local/Cellar/jenv/0.5.2/libexec/libexec/../completions/jenv.zsh'jenv rehash 2&gt;/dev/nulljenv() &#123; typeset command command="$1" if [ "$#" -gt 0 ]; then shift fi case "$command" in enable-plugin|rehash|shell|shell-options) eval `jenv "sh-$command" "$@"`;; *) command jenv "$command" "$@";; esac&#125;: No such file or directory 经过一番搜索，得到如下的解决办法，主要就是将cat替换为echo，这里我已经给jEnv提了个PR，以消除这个干扰。 Bash用户 123$ echo 'export PATH="$HOME/.jenv/bin:$PATH"' &gt;&gt; ~/.bash_profile$ echo 'eval "$(jenv init -)"' &gt;&gt; ~/.bash_profile$ exec $SHELL -l Zsh用户 123$ echo 'export PATH="$HOME/.jenv/bin:$PATH"' &gt;&gt; ~/.zshrc$ echo 'eval "$(jenv init -)"' &gt;&gt; ~/.zshrc$ exec $SHELL -l 然后再次执行jenv doctor，得到如下信息： 12345[OK] No JAVA_HOME set[ERROR] Java binary in path is not in the jenv shims.[ERROR] Please check your path, or try using /path/to/java/home is not a valid path to java installation. PATH : /usr/local/Cellar/jenv/0.5.2/libexec/libexec:/Users/xxx/.jenv/shims:/Users/xxx/.cargo/bin:/Users/xxx/.pyenv/shims:/Users/username/.pyenv:/Users/xxx/.cargo/bin:/Users/xxx/.pyenv/shims:/Users/username/.pyenv:/Users/xxx/.nvm/versions/node/v8.11.4/bin:/Users/xxx/bin:/usr/local/bin:/Users/xxx/.cargo/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/go/bin:/Users/xxx/Documents/Projects/golang/bin:/Users/xxx/Documents/Projects/golang/bin[OK] Jenv is correctly loaded 为了能够正确的设置JAVA_HOME，最好开启export插件： 12$ jenv enable-plugin export$ exec $SHELL -l 管理不同版本的JDK添加JDK添加最新安装的JDK： 1$ jenv add $(/usr/libexec/java_home) 如果/usr/libexec/java_home所指的位置不是你想要的，也可以手动指定目录： 1$ jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/ 查看JDK版本执行jenv versions： 123456 system* 1.8 (set by JENV_VERSION environment variable) 1.8.0.191 13 openjdk64-13 oracle64-1.8.0.191 默认情况下，system指的是系统中安装的最新版本的JDK。 切换JDK版本 Global设置全局模式下的JDK版本： 123$ jenv global 13$ exec $SHELL -l $ java -version Local在某个工作目录下设置JDK版本，会在当前目录下创建一个.java-version的文件： 123$ jenv local 1.8$ exec $SHELL -l $ java -version Shell设置当前Shell session中的JDK版本： 12$ jenv shell 1.8$ java -version 参考链接 http://www.jenv.be/ https://github.com/jenv/jenv https://emcorrales.com/blog/install-oracle-jdk-macos-homebrew]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jEnv</tag>
        <tag>Homebrew</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 执行 Java 程序时的内存区域划分]]></title>
    <url>%2F2019%2F09%2Fjava-virtual-machine-runtime-memory-layout%2F</url>
    <content type="text"><![CDATA[在学习 Java 虚拟机（后面简称：JVM）中的垃圾回收机制（GC）之前，先需要了解 在 JVM 中的 Java 程序（class 文件）加载到内存之后到底是怎么存的。在阅读了 JVM规范和周志明的《深入理解Java虚拟机（第2版）》之后，总结一下JVM中的内存划分以及各个区域的作用。 在JVM规范中定义了5种运行时的数据区域：程序计数器（Program Counter Register）、Java虚拟机栈（JVM Stacks）、堆（Heap）、方法区（Method Area）、运行时常量池（Runtime Constant Pool）、本地方法栈（Native Method Stack）。在周志明的书中还提到了直接内存（Direct Memory），它并不是JVM运行时数据区域的一部分，在JVM的规范中也没有相关的定义。下面分别来说明各自的用途。 程序计数器程序计数器，也叫PC Register。它的用途很单一，但是却是很多功能的基础。如果线程当前执行的是Native方法，那么寄存器里的值就是Undefined；如果线程当前执行的是非Native方法，那么寄存器里的值就是当前执行的JVM字节码指令的地址。像我们常用的分支、循环、跳转、异常处理、线程恢复等都依赖于它。 由于JVM支持多个线程同时执行，所以每个线程都有一个独立的程序计数器，各个线程互不影响，这类内存区域也称之为线程私有的。 Java虚拟机栈虚拟机栈也是线程私有的，随着一个线程的创建而创建，主要用来存储栈帧（Stack Frame）。什么是栈帧呢？在Java中，每个方法在执行时就会先创建一个栈帧并放入虚拟机栈中，在方法执行完毕时再从虚拟机栈中移除该栈帧。它主要用来存储局部变量表、操作数栈、动态链接、方法出口等信息。我们常说的堆（Heap）和栈（Stack）中的栈，指的就是虚拟机栈。 在JVM规范中并没有对虚拟机栈空间的大小做限制，可以设置为固定大小的，也可以设置为可扩展的。但是在规范中定义了两种异常情况： 如果计算时请求的栈空间大于虚拟机栈的最大值，则会抛出StackOverflowError异常； 如果虚拟机栈设置为可扩展的并且无法再获取更多内存时，则会抛出OutOfMemoryError异常。 堆相比而言，堆在JVM管理的内存区域中属于最大的一块，随着虚拟机的启动而创建，用来存储所有的class实例和数组，所有线程共享这一区域，该区域也是垃圾回收的主要区域。虽然JVM规范中说所有的对象实例都在该区域分配空间，但是随着JIT技术的逐步发展，这一说法也不严谨了。 堆空间的大小也可以设置为固定大小，或者可扩展的。但不管是何种方式，规范中还是定义了一种异常场景： 如果计算需要更多的堆空间而无法满足时，则会抛出OutOfMemoryError异常。 方法区方法区和堆一样，也是随着虚拟机启动而创建，所有线程共享，主要用来存储被JVM加载的类信息、常量、静态变量等信息。 JVM规范中并未严格要求要对该区域进行垃圾回收，但是HotSpot虚拟机在垃圾回收的时候还是会考虑该区域，在分代垃圾回收中所说的“永久代”指的就是方法区。方法区的大小也可以设置为固定大小，或者可扩展的。但不管是何种方式，规范中还是定义了一种异常场景： 如果计算需要更多的方法区空间而无法满足时，则会抛出OutOfMemoryError异常。 运行时常量池运行时常量池是方法区的一部分，用于存储编译期生成的各种字面量和符号引用。在Java中并不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中，例如String类的intern()方法。 每个运行时常量池都是随着一个类或者接口的创建而创建的。在规范中定义了一种异常场景： 在创建一个类或者接口时，如果运行时的常量池无法分配到足够的空间时，则会抛出OutOfMemoryError异常。 本地方法栈本地方法栈和虚拟机栈类似，也是线程私有的，随着一个线程的创建而创建，只不过虚拟机栈是用来服务Java方法调用，而本地方法栈是用来服务本地方法调用的。 在JVM规范中并没有对本地方法栈空间的大小做限制，可以设置为固定大小的，也可以设置为可扩展的。在规范中也定义了两种异常情况： 如果计算时请求的栈空间大于本地方法栈的最大值，则会抛出StackOverflowError异常； 如果本地方法栈设置为可扩展的并且无法再获取更多内存时，则会抛出OutOfMemoryError异常。 直接内存*直接内存不受虚拟机参数的控制，在NIO中有一种基于通道（Channel）与缓冲区（Buffer)的I/O方式，它可以通过Native方法在堆外分配内存，然后通过DirectByteBuffer对象来引用这块内存。因为避免了在Java堆和Native堆之间来回复制数据，从而在某些场景中能够得到性能的提升。一旦使用的直接内存超过了物理内存的总和，则会抛出OutOfMemoryError异常。 参考链接 https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5 https://book.douban.com/subject/24722612/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在MySQL中使用LAST_INSERT_ID获取唯一自增序列]]></title>
    <url>%2F2019%2F07%2Fimplement-sequence-with-mysql-last-insert-id%2F</url>
    <content type="text"><![CDATA[一般如果遇到生成全局唯一的自增ID的需求时，往往第一反应都是直接利用数据的Sequence对象，简单，直接了当。但是MySQL偏偏不支持Sequence对象，那我们该如何是好呢？ 什么是SequenceSequence也叫做序列，一般用做表的主键，或者一些项目的编号等。一般具有以下几个特点： 全表唯一 自增 不一定严格连续（中间由于事务的回滚可能会出现洞，比如1，2，3，5，6） 在常见的几种数据库中，Oracle、SQL Server都内置有Sequence对象，具体用法就不在此赘述了。在本文中我们来讨论一下如何在原生不支持Sequence的MySQL（目前最新的大版本为8.0）中模拟出Sequence的效果。 如何在MySQL中模拟SequenceMySQL中的auto_increment一般是用来生成表的主键，本身能够生成自增的唯一ID，但是一张表只能有一个列带有auto_increment属性。在实际项目中，我们可能需要不止一种序列号，比如项目编号（PROJ-001，PROJ-002…）、发票编号（INV-0001，INV-0002…），订单编号（ORD-0001，ORD-0002…）等等，下面将通过auto_increment和LAST_INSERT_ID相结合实现该功能。 LAST_INSERT_ID函数该函数有两种形式：LAST_INSERT_ID(), LAST_INSERT_ID(expr)。无参的形式会返回最近一次执行INSERT语句时auto_increment的值；带expr的形式会返回表达式的值，并且该值会被记住，在下一次调用LAST_INSERT_ID()时也返回该值。下面我们来看一个例子。 首先创建一张表： 1234CREATE TABLE user ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50) NOT NULL); 然后插入两条数据： 1234INSERT INTO user(name) VALUES(&apos;张三&apos;);INSERT INTO user(name) VALUES(&apos;李四&apos;);SELECT LAST_INSERT_ID(); 此时得到的结果是2。 注意：如果是一条语句插入多条值，则返回的是插入第一条时自动生成的ID，而不是最后一条的。 比如我们再插入三条数据，不过换个写法： 123456INSERT INTO user(name) VALUES(&apos;王五&apos;), (&apos;赵六&apos;), (&apos;郑七&apos;);SELECT LAST_INSERT_ID(); 此时得到的结果是3，而不是5。 获取自增序列在实际的项目中我们完全可以换个方式，避免上面👆的情况，作为一个程序员，何必没有困难，制造困难为难自己呢？接着看下一个更加通用的例子。 创建另一张表并初始化数据： 12345678CREATE TABLE sequence ( id INT AUTO_INCREMENT PRIMARY KEY, seq_type VARCHAR(50) NOT NULL, year INT NOT NULL, current_val BIGINT NOT NULL);INSERT INTO sequence(seq_type, year, current_val) VALUES(&apos;INVOICE&apos;, 2019, 0); 每次在获取current_val之前，先通过LAST_INSERT_ID(current_val + 1)更新： 12345UPDATE sequence SET current_val = LAST_INSERT_ID(current_val + 1)WHERE seq_type = &apos;INVOICE&apos; AND year = 2019;SELECT LAST_INSERT_ID(); 这样每次都能获取自增之后的值了，但是也有例外的情况。比如两个人同时在获取新的值，A先做了update操作，然后B也做了update操作，然后A的操作由于某种原因回滚了，B的操作成功了，此时序列中间就会出现一个洞。虽然不是严格连续的，但是在大多数业务场景中，已经满足要求了。 还需要注意的是，如果seq_type或者year条件不满足，那么这里的SELECT LAST_INSERT_ID();就会始终返回上一次的值，可能会导致意想不到的的错误。 LAST_INSERT_ID() vs. MAX()LAST_INSERT_ID()是以数据库连接为基础的，即使有多个人同时通过多个连接获取Sequence也不会有问题，每个客户端会获取到属于他自己的序列号，不用担心会受到其他客户端的影响，或者影响其他客户端。在这种情况下，MAX()恐怕就不能正常工作了。 参考链接 https://www.percona.com/community-blog/2018/10/12/generating-identifiers-auto_increment-sequence/ https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_last-insert-id http://www.mysqltutorial.org/mysql-last_insert_id.aspx]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F404%2F404.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[简历更新中…]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
