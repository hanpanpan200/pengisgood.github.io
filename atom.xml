<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding Life</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://codinglife.tech/"/>
  <updated>2020-09-01T14:10:54.818Z</updated>
  <id>https://codinglife.tech/</id>
  
  <author>
    <name>Max Peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>awesome-mirrors</title>
    <link href="https://codinglife.tech/2020/09/awesome-mirrors/"/>
    <id>https://codinglife.tech/2020/09/awesome-mirrors/</id>
    <published>2020-09-01T14:10:54.000Z</published>
    <updated>2020-09-01T14:10:54.818Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>加速Hyperledger Fabric的docker镜像构建过程</title>
    <link href="https://codinglife.tech/2020/08/speed-up-hyperledger-fabric-build-process/"/>
    <id>https://codinglife.tech/2020/08/speed-up-hyperledger-fabric-build-process/</id>
    <published>2020-08-18T08:26:40.000Z</published>
    <updated>2020-08-18T08:45:25.333Z</updated>
    
    <content type="html"><![CDATA[<p>Hyperledger Fabric 从<code>v2.0</code>开始，全面将docker基础镜像替换成了体积更小、潜在安全风险更少、更加轻量的<code>Alpine Linux</code>，从而使得<code>make docker</code>出来的各种镜像的体积几乎都缩小为原来的一半，确实能够节省更多的硬盘空间。但是，由于众所周知的原因，对于生在红旗下，长在新中国的程序员们，第一次在Fabric项目下构建docker镜像时，依然是奇慢无比，屡次超时。</p><p>那么这个问题怎么解决呢？</p><h2 id="分析速度的瓶颈"><a href="#分析速度的瓶颈" class="headerlink" title="分析速度的瓶颈"></a>分析速度的瓶颈</h2><p>首先通过分析速度慢的原因，找出可以优化的点。通过分析<code>make docker</code>命令，大概过程是这样的：首先是docker会从docker registry pull Alpine作为基础镜像，然后使用<code>apk add --no-cache xxx</code>安装一些软件，最后通过make命令build出Peer、Order以及其他的tools的二进制包。到这里相信国内的各种奇人义士已经磨刀霍霍，迫不及待的开始替换各种国内的mirror了。</p><a id="more"></a><p>下面的各种资源都来源于网上各位好心人的分享。</p><h2 id="加速docker-pull过程"><a href="#加速docker-pull过程" class="headerlink" title="加速docker pull过程"></a>加速docker pull过程</h2><p>首先从网上搜索国内的docker registry源，然后修改docker的配置并<strong>重启</strong>docker。在这里我比较推荐使用自己专有的免费的阿里云镜像加速器，目前使用一直比较平稳。</p><ul><li>获取镜像加速url</li></ul><p>注册一个阿里云账号并登录，在<code>产品与服务</code>中搜索<code>容器镜像服务</code>，跟随引导完成必要的一些步骤，然后来到这个页面：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors，就可以看到自己专有的加速器地址了。" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors，就可以看到自己专有的加速器地址了。</a></p><ul><li>给docker客户端配置镜像加速器</li></ul><p>如果没有<code>/etc/docker/daemon.json</code>文件，则可以直接通过下面的命令完成配置；如果该文件已经存在了，则选择自己熟悉的文本编辑器编辑该文件，添加加速器地址的配置。如果你使用的带界面的客户端，也可以在<code>Preferences... -&gt; Docker Engine</code>显示的编辑器中添加相应的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://xxx.mirror.aliyuncs.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：将<code>https://xxx.mirror.aliyuncs.com</code>替换成你自己的镜像加速器地址。再次提醒，配置完成后，<strong>重启</strong>docker之后才会生效。</p><p>至此我们完成了docker pull镜像阶段的加速，接下来我们加速在Alpine中安装软件的过程。</p><h2 id="加速Alpine安装软件的过程"><a href="#加速Alpine安装软件的过程" class="headerlink" title="加速Alpine安装软件的过程"></a>加速Alpine安装软件的过程</h2><p>在docker pull下来的Alpine镜像中，使用apk安装软件时默认使用的是国外的源，速度比较慢。这里我们把源替换为国内的源，可以大大节省时间。下面以Hyperledger fabric peer的<a href="https://github.com/hyperledger/fabric/blob/master/images/peer/Dockerfile" target="_blank" rel="noopener">Dockerfile</a>为例，替换为阿里的源：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:$&#123;ALPINE_VER&#125; as peer-base</span><br><span class="line"><span class="comment"># 使用下面这行命令完成源的替换</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g'</span> /etc/apk/repositories</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache tzdata</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> golang:$&#123;GO_VER&#125;-alpine$&#123;ALPINE_VER&#125; as golang</span><br><span class="line"><span class="comment"># 使用下面这行命令完成源的替换</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g'</span> /etc/apk/repositories</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache \</span></span><br><span class="line"><span class="bash">bash \</span></span><br><span class="line"><span class="bash">gcc \</span></span><br><span class="line"><span class="bash">git \</span></span><br><span class="line"><span class="bash">make \</span></span><br><span class="line"><span class="bash">musl-dev</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>另外也可以替换为中科大的源：dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn，或者清华的源：dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn，或者其他的源。</p><p><strong>注意</strong>：这里对于使用multi-stage的Dockerfile，如果不同的stage使用的是不同的基础镜像，则都需要替换源。</p><p>到这里，当docker使用Alpine作为基础镜像时，安装依赖软件的过程就会快很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hyperledger Fabric 从&lt;code&gt;v2.0&lt;/code&gt;开始，全面将docker基础镜像替换成了体积更小、潜在安全风险更少、更加轻量的&lt;code&gt;Alpine Linux&lt;/code&gt;，从而使得&lt;code&gt;make docker&lt;/code&gt;出来的各种镜像的体积几乎都缩小为原来的一半，确实能够节省更多的硬盘空间。但是，由于众所周知的原因，对于生在红旗下，长在新中国的程序员们，第一次在Fabric项目下构建docker镜像时，依然是奇慢无比，屡次超时。&lt;/p&gt;
&lt;p&gt;那么这个问题怎么解决呢？&lt;/p&gt;
&lt;h2 id=&quot;分析速度的瓶颈&quot;&gt;&lt;a href=&quot;#分析速度的瓶颈&quot; class=&quot;headerlink&quot; title=&quot;分析速度的瓶颈&quot;&gt;&lt;/a&gt;分析速度的瓶颈&lt;/h2&gt;&lt;p&gt;首先通过分析速度慢的原因，找出可以优化的点。通过分析&lt;code&gt;make docker&lt;/code&gt;命令，大概过程是这样的：首先是docker会从docker registry pull Alpine作为基础镜像，然后使用&lt;code&gt;apk add --no-cache xxx&lt;/code&gt;安装一些软件，最后通过make命令build出Peer、Order以及其他的tools的二进制包。到这里相信国内的各种奇人义士已经磨刀霍霍，迫不及待的开始替换各种国内的mirror了。&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://codinglife.tech/categories/blockchain/"/>
    
    
      <category term="docker" scheme="https://codinglife.tech/tags/docker/"/>
    
      <category term="hyperledger-fabric" scheme="https://codinglife.tech/tags/hyperledger-fabric/"/>
    
  </entry>
  
  <entry>
    <title>Mac上的JDK多版本管理</title>
    <link href="https://codinglife.tech/2019/09/manage-multiple-java-versions-on-mac/"/>
    <id>https://codinglife.tech/2019/09/manage-multiple-java-versions-on-mac/</id>
    <published>2019-09-24T07:27:36.000Z</published>
    <updated>2020-08-10T06:44:10.900Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jenv.png" alt="jEnv"><br>我的Mac上已经有一个JDK8的版本了，这不<a href="http://openjdk.java.net/projects/jdk/13/" target="_blank" rel="noopener">JDK13</a>刚发布（2019-09-17），想快速的尝一尝鲜，就得安装多个版本的JDK了。这个对Node、Ruby、Python的使用者来说，已经不是个什么新鲜话题了，但是对于Java的使用者来说，似乎没有那么多的人受到过多版本的折磨（我是通过GitHub上<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener"><code>nvm</code></a>、<a href="https://github.com/rbenv/rbenv" target="_blank" rel="noopener"><code>rbenv</code></a>、<a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener"><code>pyenv</code></a>、<a href="https://github.com/jenv/jenv" target="_blank" rel="noopener"><code>jenv</code></a>的Star数量臆测出这个结论的 :P）。</p><a id="more"></a><ul><li>nvm<iframe src="https://ghbtns.com/github-btn.html?user=nvm-sh&repo=nvm&type=star&count=true" frameborder="0" scrolling="0" width="200px" height="20px" style="vertical-align:middle"></iframe></li><li>rbenv<iframe src="https://ghbtns.com/github-btn.html?user=rbenv&repo=rbenv&type=star&count=true" frameborder="0" scrolling="0" width="200px" height="20px" style="vertical-align:middle"></iframe></li><li>pyenv<iframe src="https://ghbtns.com/github-btn.html?user=pyenv&repo=pyenv&type=star&count=true" frameborder="0" scrolling="0" width="200px" height="20px" style="vertical-align:middle"></iframe></li><li>jenv<iframe src="https://ghbtns.com/github-btn.html?user=jenv&repo=jenv&type=star&count=true" frameborder="0" scrolling="0" width="200px" height="20px" style="vertical-align:middle"></iframe></li></ul><h2 id="安装JDK-13"><a href="#安装JDK-13" class="headerlink" title="安装JDK 13"></a>安装JDK 13</h2><p>通过Homebrew 安装JDK 13，可以先通过<code>brew cask info java</code>查看目前Java的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java: 13,33:5b8a42f3905b406298b72d750b6919f6</span><br><span class="line">https://openjdk.java.net/</span><br><span class="line">Not installed</span><br><span class="line">From: https://github.com/Homebrew/homebrew-cask/blob/master/Casks/java.rb</span><br><span class="line">==&gt; Name</span><br><span class="line">OpenJDK Java Development Kit</span><br><span class="line">==&gt; Artifacts</span><br><span class="line">jdk-13.jdk -&gt; /Library/Java/JavaVirtualMachines/openjdk-13.jdk (Generic Artifact)</span><br></pre></td></tr></table></figure><p>这里显示的是JDK13，正好是我想要安装的JDK版本，如果不是你想要的版本可以自己搜索相应的 Homebrew Tap。接下来直接安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install java</span><br><span class="line">$ java -version</span><br><span class="line"></span><br><span class="line">openjdk version <span class="string">"13"</span> 2019-09-17</span><br><span class="line">OpenJDK Runtime Environment (build 13+33)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 13+33, mixed mode, sharing)</span><br></pre></td></tr></table></figure><p>这就说明JDK13已经安装好了。</p><p>但是另一个问题来了，我电脑上原来安装的JDK8去哪呢？我如何在不同的版本中随意切换呢？比如像Node的<code>nvm</code>，Ruby的<code>rvm</code>，Python的<code>pyenv</code>等。答案是我们可以通过<code>jenv</code>来实现相同的效果。</p><h2 id="安装-jEnv"><a href="#安装-jEnv" class="headerlink" title="安装 jEnv"></a>安装 jEnv</h2><ol><li>安装 jEnv</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install jenv</span><br><span class="line">$ <span class="built_in">exec</span> <span class="variable">$SHELL</span> -l</span><br></pre></td></tr></table></figure><p>安装完成之后，然后检查是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ jenv doctor</span><br><span class="line">[OK]No JAVA_HOME <span class="built_in">set</span></span><br><span class="line">[ERROR]Java binary <span class="keyword">in</span> path is not <span class="keyword">in</span> the jenv shims.</span><br><span class="line">[ERROR]Please check your path, or try using /path/to/java/home is not a valid path to java installation.</span><br><span class="line">PATH : /usr/<span class="built_in">local</span>/Cellar/jenv/0.5.2/libexec/libexec:/Users/xxx/.cargo/bin:/Users/xxx/.pyenv/shims:/Users/username/.pyenv:/Users/xxx/.nvm/versions/node/v8.11.4/bin:/Users/xxx/bin:/usr/<span class="built_in">local</span>/bin:/Users/xxx/.cargo/bin:/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/<span class="built_in">local</span>/go/bin:/Users/xxx/Documents/Projects/golang/bin</span><br><span class="line">[ERROR]Jenv is not loaded <span class="keyword">in</span> your zsh</span><br><span class="line">[ERROR]To fix : cat <span class="built_in">eval</span> <span class="string">"<span class="variable">$(jenv init -)</span>"</span> &gt;&gt; /Users/xxx/.zshrc</span><br></pre></td></tr></table></figure><p>在这里如果按照提示执行<code>cat eval &quot;$(jenv init -)&quot; &gt;&gt; /Users/xxx/.zshrc</code>：可能会得到如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">eval</span> <span class="string">"<span class="variable">$(jenv init -)</span>"</span> &gt;&gt; /Users/xxx/.zshrc</span><br><span class="line">cat: <span class="built_in">eval</span>: No such file or directory</span><br><span class="line">cat: <span class="built_in">export</span> PATH=<span class="string">"/Users/xxx/.jenv/shims:<span class="variable">$&#123;PATH&#125;</span>"</span></span><br><span class="line"><span class="built_in">export</span> JENV_SHELL=zsh</span><br><span class="line"><span class="built_in">export</span> JENV_LOADED=1</span><br><span class="line"><span class="built_in">unset</span> JAVA_HOME</span><br><span class="line"><span class="built_in">source</span> <span class="string">'/usr/local/Cellar/jenv/0.5.2/libexec/libexec/../completions/jenv.zsh'</span></span><br><span class="line">jenv <span class="built_in">rehash</span> 2&gt;/dev/null</span><br><span class="line"><span class="function"><span class="title">jenv</span></span>() &#123;</span><br><span class="line">  <span class="built_in">typeset</span> <span class="built_in">command</span></span><br><span class="line">  <span class="built_in">command</span>=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$#</span>"</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"<span class="variable">$command</span>"</span> <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">enable</span>-plugin|<span class="built_in">rehash</span>|shell|shell-options)</span><br><span class="line">    <span class="built_in">eval</span> `jenv <span class="string">"sh-<span class="variable">$command</span>"</span> <span class="string">"<span class="variable">$@</span>"</span>`;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">command</span> jenv <span class="string">"<span class="variable">$command</span>"</span> <span class="string">"<span class="variable">$@</span>"</span>;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">&#125;: No such file or directory</span><br></pre></td></tr></table></figure><p>经过一番搜索，得到如下的解决办法，主要就是将<code>cat</code>替换为<code>echo</code>，这里我已经给jEnv提了个<a href="https://github.com/jenv/jenv/pull/265" target="_blank" rel="noopener">PR</a>，以消除这个干扰。</p><ul><li><p>Bash用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'export PATH="$HOME/.jenv/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'eval "$(jenv init -)"'</span> &gt;&gt; ~/.bash_profile</span><br><span class="line">$ <span class="built_in">exec</span> <span class="variable">$SHELL</span> -l</span><br></pre></td></tr></table></figure></li><li><p>Zsh用户</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'export PATH="$HOME/.jenv/bin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'eval "$(jenv init -)"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line">$ <span class="built_in">exec</span> <span class="variable">$SHELL</span> -l</span><br></pre></td></tr></table></figure></li></ul><p>然后再次执行<code>jenv doctor</code>，得到如下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[OK]No JAVA_HOME <span class="built_in">set</span></span><br><span class="line">[ERROR]Java binary <span class="keyword">in</span> path is not <span class="keyword">in</span> the jenv shims.</span><br><span class="line">[ERROR]Please check your path, or try using /path/to/java/home is not a valid path to java installation.</span><br><span class="line">PATH : /usr/<span class="built_in">local</span>/Cellar/jenv/0.5.2/libexec/libexec:/Users/xxx/.jenv/shims:/Users/xxx/.cargo/bin:/Users/xxx/.pyenv/shims:/Users/username/.pyenv:/Users/xxx/.cargo/bin:/Users/xxx/.pyenv/shims:/Users/username/.pyenv:/Users/xxx/.nvm/versions/node/v8.11.4/bin:/Users/xxx/bin:/usr/<span class="built_in">local</span>/bin:/Users/xxx/.cargo/bin:/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/<span class="built_in">local</span>/go/bin:/Users/xxx/Documents/Projects/golang/bin:/Users/xxx/Documents/Projects/golang/bin</span><br><span class="line">[OK]Jenv is correctly loaded</span><br></pre></td></tr></table></figure><p>为了能够正确的设置<code>JAVA_HOME</code>，最好开启<code>export</code>插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jenv <span class="built_in">enable</span>-plugin <span class="built_in">export</span></span><br><span class="line">$ <span class="built_in">exec</span> <span class="variable">$SHELL</span> -l</span><br></pre></td></tr></table></figure><p>如果你是Maven用户，建议开启Maven插件，使得Maven能够使用正确的JDK版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jenv <span class="built_in">enable</span>-plugin maven</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exec</span> <span class="variable">$SHELL</span> -l</span></span><br></pre></td></tr></table></figure><h2 id="管理不同版本的JDK"><a href="#管理不同版本的JDK" class="headerlink" title="管理不同版本的JDK"></a>管理不同版本的JDK</h2><h3 id="添加JDK"><a href="#添加JDK" class="headerlink" title="添加JDK"></a>添加JDK</h3><p>添加最新安装的JDK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jenv add $(/usr/libexec/java_home)</span><br></pre></td></tr></table></figure><p>如果<code>/usr/libexec/java_home</code>所指的位置不是你想要的，也可以手动指定目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/</span><br></pre></td></tr></table></figure><h3 id="查看JDK版本"><a href="#查看JDK版本" class="headerlink" title="查看JDK版本"></a>查看JDK版本</h3><p>执行<code>jenv versions</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  system</span><br><span class="line">* 1.8 (<span class="built_in">set</span> by JENV_VERSION environment variable)</span><br><span class="line">  1.8.0.191</span><br><span class="line">  13</span><br><span class="line">  openjdk64-13</span><br><span class="line">  oracle64-1.8.0.191</span><br></pre></td></tr></table></figure><p>默认情况下，system指的是系统中安装的最新版本的JDK。</p><h3 id="切换JDK版本"><a href="#切换JDK版本" class="headerlink" title="切换JDK版本"></a>切换JDK版本</h3><ul><li><p>Global<br>设置全局模式下的JDK版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jenv global 13</span><br><span class="line">$ <span class="built_in">exec</span> <span class="variable">$SHELL</span> -l </span><br><span class="line">$ java -version</span><br></pre></td></tr></table></figure></li><li><p>Local<br>在某个工作目录下设置JDK版本，会在当前目录下创建一个<code>.java-version</code>的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jenv <span class="built_in">local</span> 1.8</span><br><span class="line">$ <span class="built_in">exec</span> <span class="variable">$SHELL</span> -l </span><br><span class="line">$ java -version</span><br></pre></td></tr></table></figure></li><li><p>Shell<br>设置当前Shell session中的JDK版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jenv shell 1.8</span><br><span class="line">$ java -version</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><ul><li><a href="http://www.jenv.be/" target="_blank" rel="noopener">http://www.jenv.be/</a></li><li><a href="https://github.com/jenv/jenv" target="_blank" rel="noopener">https://github.com/jenv/jenv</a></li><li><a href="https://emcorrales.com/blog/install-oracle-jdk-macos-homebrew" target="_blank" rel="noopener">https://emcorrales.com/blog/install-oracle-jdk-macos-homebrew</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jenv.png&quot; alt=&quot;jEnv&quot;&gt;&lt;br&gt;我的Mac上已经有一个JDK8的版本了，这不&lt;a href=&quot;http://openjdk.java.net/projects/jdk/13/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JDK13&lt;/a&gt;刚发布（2019-09-17），想快速的尝一尝鲜，就得安装多个版本的JDK了。这个对Node、Ruby、Python的使用者来说，已经不是个什么新鲜话题了，但是对于Java的使用者来说，似乎没有那么多的人受到过多版本的折磨（我是通过GitHub上&lt;a href=&quot;https://github.com/nvm-sh/nvm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;nvm&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://github.com/rbenv/rbenv&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;rbenv&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://github.com/pyenv/pyenv&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;pyenv&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://github.com/jenv/jenv&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;jenv&lt;/code&gt;&lt;/a&gt;的Star数量臆测出这个结论的 :P）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://codinglife.tech/categories/Java/"/>
    
    
      <category term="JDK" scheme="https://codinglife.tech/tags/JDK/"/>
    
      <category term="jEnv" scheme="https://codinglife.tech/tags/jEnv/"/>
    
      <category term="Homebrew" scheme="https://codinglife.tech/tags/Homebrew/"/>
    
  </entry>
  
  <entry>
    <title>JVM 执行 Java 程序时的内存区域划分</title>
    <link href="https://codinglife.tech/2019/09/java-virtual-machine-runtime-memory-layout/"/>
    <id>https://codinglife.tech/2019/09/java-virtual-machine-runtime-memory-layout/</id>
    <published>2019-09-17T02:28:03.000Z</published>
    <updated>2020-04-15T02:42:06.608Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jvm-memory-layout.png" alt="JVM Memory Layout"></p><p>在学习 Java 虚拟机（后面简称：<code>JVM</code>）中的垃圾回收机制（GC）之前，先需要了解 在 JVM 中的 Java 程序（class 文件）加载到内存之后到底是怎么存的。在阅读了 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener"><strong>JVM规范</strong></a>和周志明的<a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener"><strong>《深入理解Java虚拟机（第2版）》</strong></a>之后，总结一下JVM中的内存划分以及各个区域的作用。</p><a id="more"></a><p>在JVM规范中定义了5种运行时的数据区域：程序计数器（Program Counter Register）、Java虚拟机栈（JVM Stacks）、堆（Heap）、方法区（Method Area）、运行时常量池（Runtime Constant Pool）、本地方法栈（Native Method Stack）。在周志明的书中还提到了直接内存（Direct Memory），它并不是JVM运行时数据区域的一部分，在JVM的规范中也没有相关的定义。下面分别来说明各自的用途。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器，也叫PC Register。它的用途很单一，但是却是很多功能的基础。如果线程当前执行的是Native方法，那么寄存器里的值就是Undefined；如果线程当前执行的是非Native方法，那么寄存器里的值就是当前执行的JVM字节码指令的地址。像我们常用的分支、循环、跳转、异常处理、线程恢复等都依赖于它。</p><p>由于JVM支持多个线程同时执行，所以每个线程都有一个独立的程序计数器，各个线程互不影响，这类内存区域也称之为<strong>线程私有</strong>的。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>虚拟机栈也是<strong>线程私有</strong>的，随着一个线程的创建而创建，主要用来存储栈帧（Stack Frame）。什么是栈帧呢？在Java中，每个方法在执行时就会先创建一个栈帧并放入虚拟机栈中，在方法执行完毕时再从虚拟机栈中移除该栈帧。它主要用来存储局部变量表、操作数栈、动态链接、方法出口等信息。我们常说的堆（Heap）和栈（Stack）中的栈，指的就是虚拟机栈。</p><p>在JVM规范中并没有对虚拟机栈空间的大小做限制，可以设置为固定大小的，也可以设置为可扩展的。但是在规范中定义了两种异常情况：</p><ul><li>如果计算时请求的栈空间大于虚拟机栈的最大值，则会抛出<code>StackOverflowError</code>异常；</li><li>如果虚拟机栈设置为可扩展的并且无法再获取更多内存时，则会抛出<code>OutOfMemoryError</code>异常。</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>相比而言，堆在JVM管理的内存区域中属于最大的一块，随着虚拟机的启动而创建，用来存储所有的class实例和数组，所有<strong>线程共享</strong>这一区域，该区域也是垃圾回收的主要区域。虽然JVM规范中说所有的对象实例都在该区域分配空间，但是随着JIT技术的逐步发展，这一说法也不严谨了。</p><p>堆空间的大小也可以设置为固定大小，或者可扩展的。但不管是何种方式，规范中还是定义了一种异常场景：</p><ul><li>如果计算需要更多的堆空间而无法满足时，则会抛出<code>OutOfMemoryError</code>异常。</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区和堆一样，也是随着虚拟机启动而创建，所有<strong>线程共享</strong>，主要用来存储被JVM加载的类信息、常量、静态变量等信息。</p><p>JVM规范中并未严格要求要对该区域进行垃圾回收，但是HotSpot虚拟机在垃圾回收的时候还是会考虑该区域，在分代垃圾回收中所说的“<strong>永久代</strong>”指的就是方法区。方法区的大小也可以设置为固定大小，或者可扩展的。但不管是何种方式，规范中还是定义了一种异常场景：</p><ul><li>如果计算需要更多的方法区空间而无法满足时，则会抛出<code>OutOfMemoryError</code>异常。</li></ul><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分，用于存储编译期生成的各种字面量和符号引用。在Java中并不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中，例如<code>String</code>类的<code>intern()</code>方法。</p><p>每个运行时常量池都是随着一个类或者接口的创建而创建的。在规范中定义了一种异常场景：</p><ul><li>在创建一个类或者接口时，如果运行时的常量池无法分配到足够的空间时，则会抛出<code>OutOfMemoryError</code>异常。</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈和虚拟机栈类似，也是<strong>线程私有</strong>的，随着一个线程的创建而创建，只不过虚拟机栈是用来服务Java方法调用，而本地方法栈是用来服务本地方法调用的。</p><p>在JVM规范中并没有对本地方法栈空间的大小做限制，可以设置为固定大小的，也可以设置为可扩展的。在规范中也定义了两种异常情况：</p><ul><li>如果计算时请求的栈空间大于本地方法栈的最大值，则会抛出<code>StackOverflowError</code>异常；</li><li>如果本地方法栈设置为可扩展的并且无法再获取更多内存时，则会抛出<code>OutOfMemoryError</code>异常。</li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存*"></a>直接内存<sup>*</sup></h2><p>直接内存不受虚拟机参数的控制，在NIO中有一种基于通道（Channel）与缓冲区（Buffer)的I/O方式，它可以通过Native方法在堆外分配内存，然后通过DirectByteBuffer对象来引用这块内存。因为避免了在Java堆和Native堆之间来回复制数据，从而在某些场景中能够得到性能的提升。一旦使用的直接内存超过了物理内存的总和，则会抛出<code>OutOfMemoryError</code>异常。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5</a></li><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">https://book.douban.com/subject/24722612/</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jvm-memory-layout.png&quot; alt=&quot;JVM Memory Layout&quot;&gt;&lt;/p&gt;
&lt;p&gt;在学习 Java 虚拟机（后面简称：&lt;code&gt;JVM&lt;/code&gt;）中的垃圾回收机制（GC）之前，先需要了解 在 JVM 中的 Java 程序（class 文件）加载到内存之后到底是怎么存的。在阅读了 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;JVM规范&lt;/strong&gt;&lt;/a&gt;和周志明的&lt;a href=&quot;https://book.douban.com/subject/24722612/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;《深入理解Java虚拟机（第2版）》&lt;/strong&gt;&lt;/a&gt;之后，总结一下JVM中的内存划分以及各个区域的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://codinglife.tech/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://codinglife.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>在MySQL中使用LAST_INSERT_ID获取唯一自增序列</title>
    <link href="https://codinglife.tech/2019/07/implement-sequence-with-mysql-last-insert-id/"/>
    <id>https://codinglife.tech/2019/07/implement-sequence-with-mysql-last-insert-id/</id>
    <published>2019-07-15T12:03:02.000Z</published>
    <updated>2020-04-15T02:42:06.608Z</updated>
    
    <content type="html"><![CDATA[<p>一般如果遇到生成全局唯一的自增ID的需求时，往往第一反应都是直接利用数据的Sequence对象，简单，直接了当。但是MySQL偏偏不支持Sequence对象，那我们该如何是好呢？</p><h2 id="什么是Sequence"><a href="#什么是Sequence" class="headerlink" title="什么是Sequence"></a>什么是Sequence</h2><p>Sequence也叫做序列，一般用做表的主键，或者一些项目的编号等。一般具有以下几个特点：</p><ul><li>全表唯一</li><li>自增</li><li>不一定严格连续（中间由于事务的回滚可能会出现<code>洞</code>，比如1，2，3，5，6）</li></ul><a id="more"></a><p>在常见的几种数据库中，Oracle、SQL Server都内置有Sequence对象，具体用法就不在此赘述了。在本文中我们来讨论一下如何在原生不支持Sequence的MySQL（目前最新的大版本为8.0）中模拟出Sequence的效果。</p><h2 id="如何在MySQL中模拟Sequence"><a href="#如何在MySQL中模拟Sequence" class="headerlink" title="如何在MySQL中模拟Sequence"></a>如何在MySQL中模拟Sequence</h2><p>MySQL中的<code>auto_increment</code>一般是用来生成表的主键，本身能够生成自增的唯一ID，但是一张表只能有一个列带有<code>auto_increment</code>属性。在实际项目中，我们可能需要不止一种序列号，比如项目编号（PROJ-001，PROJ-002…）、发票编号（INV-0001，INV-0002…），订单编号（ORD-0001，ORD-0002…）等等，下面将通过<code>auto_increment</code>和<code>LAST_INSERT_ID</code>相结合实现该功能。</p><h3 id="LAST-INSERT-ID函数"><a href="#LAST-INSERT-ID函数" class="headerlink" title="LAST_INSERT_ID函数"></a>LAST_INSERT_ID函数</h3><p>该函数有两种形式：<a href="https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_last-insert-id" target="_blank" rel="noopener"><code>LAST_INSERT_ID()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_last-insert-id" target="_blank" rel="noopener"><code>LAST_INSERT_ID(expr)</code></a>。无参的形式会返回最近一次执行<code>INSERT</code>语句时<code>auto_increment</code>的值；带<code>expr</code>的形式会返回表达式的值，并且该值会被记住，在下一次调用<code>LAST_INSERT_ID()</code>时也返回该值。下面我们来看一个例子。</p><p>首先创建一张表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(50) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后插入两条数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO user(name) VALUES(&apos;张三&apos;);</span><br><span class="line">INSERT INTO user(name) VALUES(&apos;李四&apos;);</span><br><span class="line"></span><br><span class="line">SELECT LAST_INSERT_ID();</span><br></pre></td></tr></table></figure><p>此时得到的结果是2。</p><p><strong>注意：</strong>如果是一条语句插入多条值，则返回的是插入第一条时自动生成的ID，而不是最后一条的。</p><p>比如我们再插入三条数据，不过换个写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO user(name) </span><br><span class="line">VALUES(&apos;王五&apos;),</span><br><span class="line">      (&apos;赵六&apos;),</span><br><span class="line">      (&apos;郑七&apos;);</span><br><span class="line"></span><br><span class="line">SELECT LAST_INSERT_ID();</span><br></pre></td></tr></table></figure><p>此时得到的结果是3，而<strong>不是</strong>5。</p><h3 id="获取自增序列"><a href="#获取自增序列" class="headerlink" title="获取自增序列"></a>获取自增序列</h3><p>在实际的项目中我们完全可以换个方式，避免上面👆的情况，作为一个程序员，何必没有困难，制造困难为难自己呢？接着看下一个更加通用的例子。</p><p>创建另一张表并初始化数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sequence (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    seq_type VARCHAR(50) NOT NULL,</span><br><span class="line">    year INT NOT NULL,</span><br><span class="line">    current_val BIGINT NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO sequence(seq_type, year, current_val) VALUES(&apos;INVOICE&apos;, 2019, 0);</span><br></pre></td></tr></table></figure><p>每次在获取<code>current_val</code>之前，先通过<code>LAST_INSERT_ID(current_val + 1)</code>更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE sequence </span><br><span class="line">SET current_val = LAST_INSERT_ID(current_val + 1)</span><br><span class="line">WHERE seq_type = &apos;INVOICE&apos; AND year = 2019;</span><br><span class="line"></span><br><span class="line">SELECT LAST_INSERT_ID();</span><br></pre></td></tr></table></figure><p>这样每次都能获取自增之后的值了，但是也有例外的情况。比如两个人同时在获取新的值，A先做了update操作，然后B也做了update操作，然后A的操作由于某种原因回滚了，B的操作成功了，此时序列中间就会出现一个<code>洞</code>。虽然不是严格连续的，但是在大多数业务场景中，已经满足要求了。</p><p><strong>还需要注意的是</strong>，如果<code>seq_type</code>或者<code>year</code>条件不满足，那么这里的<code>SELECT LAST_INSERT_ID();</code>就会始终返回上一次的值，可能会导致意想不到的的错误。</p><h2 id="LAST-INSERT-ID-vs-MAX"><a href="#LAST-INSERT-ID-vs-MAX" class="headerlink" title="LAST_INSERT_ID() vs. MAX()"></a>LAST_INSERT_ID() vs. MAX()</h2><p><code>LAST_INSERT_ID()</code>是以数据库连接为基础的，即使有多个人同时通过多个连接获取Sequence也不会有问题，每个客户端会获取到属于他自己的序列号，不用担心会受到其他客户端的影响，或者影响其他客户端。在这种情况下，<code>MAX()</code>恐怕就不能正常工作了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><ul><li><a href="https://www.percona.com/community-blog/2018/10/12/generating-identifiers-auto_increment-sequence/" target="_blank" rel="noopener">https://www.percona.com/community-blog/2018/10/12/generating-identifiers-auto_increment-sequence/</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_last-insert-id" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_last-insert-id</a></li><li><a href="http://www.mysqltutorial.org/mysql-last_insert_id.aspx" target="_blank" rel="noopener">http://www.mysqltutorial.org/mysql-last_insert_id.aspx</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般如果遇到生成全局唯一的自增ID的需求时，往往第一反应都是直接利用数据的Sequence对象，简单，直接了当。但是MySQL偏偏不支持Sequence对象，那我们该如何是好呢？&lt;/p&gt;
&lt;h2 id=&quot;什么是Sequence&quot;&gt;&lt;a href=&quot;#什么是Sequence&quot; class=&quot;headerlink&quot; title=&quot;什么是Sequence&quot;&gt;&lt;/a&gt;什么是Sequence&lt;/h2&gt;&lt;p&gt;Sequence也叫做序列，一般用做表的主键，或者一些项目的编号等。一般具有以下几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全表唯一&lt;/li&gt;
&lt;li&gt;自增&lt;/li&gt;
&lt;li&gt;不一定严格连续（中间由于事务的回滚可能会出现&lt;code&gt;洞&lt;/code&gt;，比如1，2，3，5，6）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="database" scheme="https://codinglife.tech/categories/database/"/>
    
    
      <category term="mysql" scheme="https://codinglife.tech/tags/mysql/"/>
    
  </entry>
  
</feed>
